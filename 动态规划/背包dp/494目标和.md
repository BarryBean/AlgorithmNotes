# 题目描述
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

> 示例 1:
> 
> 输入: nums: [1, 1, 1, 1, 1], S: 3
> 
> 输出: 5
> 
> 解释: 
> 
> -1+1+1+1+1 = 3
> 
> +1-1+1+1+1 = 3
> 
> +1+1-1+1+1 = 3
> 
> +1+1+1-1+1 = 3
> 
> +1+1+1+1-1 = 3
> 
> 一共有5种方法让最终目标和为3。


注意:
- 数组非空，且长度不会超过20。
- 初始的数组的和不会超过1000。
- 保证返回的最终结果能被32位整数存下。

# 思路分析
将问题转换为，在 nums 中找一个正子集和一个负子集，总和为 S。

1. 先求出数组中的总和，若总和 < S，直接为 0。
2. sum-S 就是差值，但将 +x 变为 -x，实际上出入是 2x，所以目标值是 (sum-S)/2。
3. 之后就是 0-1背包问题，一维数组的第二层循环要从后往前。


# 代码实现
```
    public static int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum < S || (sum - S) % 2 == 1) {
            return 0;
        }
     
        int target = (sum - S) / 2;
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 0; i < nums.length; i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[target];
    }
```