详细推荐《背包九讲》。

# 0-1 背包
## 二维数组
1. 明确状态和选择。
- 状态：背包容量和可选择的物品；
- 选择：放进背包和不放进背包。
2. 明确 dp 数组定义。
- dp[i][w] 对于**前 i 个物品，当前背包容量为 w 情况下能装的最大价值**。
- base case：dp[0][...]=dp[...][0]=0，物品数量为0或背包容量为0。
3. 写出转移方程。
- 第 i 个物品没有放进背包 => dp[i][w] = dp[i-1][w]；
- 第 i 个物品放进背包 => dp[i][w] = dp[i-1][w-wt[i]] + v[i]；

```java
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i-1] < 0) {
                //这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                //装入或者不装入背包，择优
                dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], 
                               dp[i - 1][w]);
            }
        }
    }
```

## 一维数组
我们发现 dp[i][w] 是由 dp[i-1][w] 和 dp[i-1][w-wt[i]] 得来，所以我们可以只保存一维的数据。

前提是 `为了得到新值，不能覆盖旧值`，即保证 dp[i][w] 的值必须是由 dp[i-1][w] 和 dp[i-1][w-wt[i]]得到，不能出现被覆盖为 dp[i][w] 和 dp[i][w-wt[i]] 的情况。

所以 **0-1背包一维的第二层循环是从后往前推**，保证当前更新值都是由上一次状态值得到，**对应0-1背包每个物品只用一次**。


```java
    for (int i = 1; i <= N; i++) {
        for (int w = W; w >= wt[i]; w--) {
                dp[w] = max(dp[w - wt[i]] + val[i], dp[w]);
            }
        }
    }
```

## 变体

416 分割等和子集


# 完全背包
完全背包问题的改变在于：物品可以选取任意次。


## 一维数组

**完全背包一维的第二层循环是从前往后推**，所以会有重复选取的可能，**对应完全背包每个物品能无限选取**。


```java
    for (int i = 1; i <= N; i++) {
        for (int w = wt[i]; w <= V; w++) {
                dp[w] = max(dp[w - wt[i]] + val[i], dp[w]);
            }
        }
    }
```

完全背包的两层 for 循环能够颠倒，在特定情况下，一个是求排列数，一个是求组合数。

322零钱兑换

416零钱兑换II

